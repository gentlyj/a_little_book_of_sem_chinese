# 第1章

## 引言

### 1.1 同步机制

日常生活中，"同步" 通常指让两个事件同时发生。在计算机系统中，同步的含义更为广泛——它描述事件之间的时序关系（先于、同时、后于等），这种关系可以涉及任意数量的事件。



程序员常关注同步约束条件，即关于事件顺序的强制性要求。典型场景包括：



​​序列化​​：事件 A 必须发生在事件 B 之前
​​互斥​​：事件 A 与事件 B 不可同时发生



在现实生活中，我们经常使用时钟来检查和强制同步约束。如何判断A是否发生在B之前？如果我们知道两个事件发生的时间，就可以直接比较时间。



但在计算机系统中，我们通常需要在没有时钟的情况下满足同步约束，要么是因为没有通用的时钟，要么是因为我们无法以足够高的精度知道事件发生的时间。这就是本书的主题：用于强制同步约束的软件技术。



### 1.2 执行模型

理解软件同步需要建立程序执行模型。在单线程顺序执行模型中，指令按代码顺序依次执行，同步问题几乎不存在。但以下两种复杂情况改变了这一局面：



**并行计算**：多处理器同时运行不同指令，难以判断跨处理器指令的执行顺序。  
**多线程**：单处理器通过时间片轮转执行多个指令序列（线程），操作系统调度决定线程切换时机。  

无论是并行还是多线程模型，核心挑战相同——同一处理器（线程）内的指令顺序可知，跨处理器（线程）的指令顺序不可预测。



现实案例有助于理解：假设你与异地好友Bob各自午餐，如何确定谁先用餐？虽然可通过电话询问时间，但若两地的时钟存在误差（例如你的11:59与Bob的12:01），实际顺序仍无法确定。



计算机系统面临同样的问题，因为即使它们的时钟通常很准确，但其精度总是有限的。此外，大多数时候计算机并不记录事件发生的时间。事情发生得太快、太多，无法精确记录每一件事的确切时间。



**思考题**：假设鲍勃愿意听从简单的安排，有没有办法保证你明天会在鲍勃之前吃午饭？


### 1.3 基于消息的序列化



解决方案：要求 Bob 在接到你的电话后才开始吃午餐，你吃午餐后才打这个电话。这种消息传递机制虽简单，却是解决同步问题的核心方法。以下是执行时序示例：



| Thread A (You) | Thread B (Bob) |
|---------------------|----------------------|
| `1` Eat breakfast | `1` Eat breakfast |
| `2` Work | `2` Wait for a call |
| `3` Eat lunch | `3` Eat lunch |
| `4` Call Bob | | 

第一列是你执行的操作；或者说你的执行线程。第二列是鲍勃的执行线程。在同一个线程中，始终可以确定事件发生的顺序。通过事件顺序标记：

a1 < a2 < a3 < a4   
b1 < b2 < b3   

其中：a1 < a2 表示 a1 发生在 a2 之前   

一般来说，无法比较不同线程中的事件；例如，我们不知道谁先吃了早餐（a1 < b1？）。但通过消息传递（电话），我们可以知道谁先吃了午餐（a3 < b3）。做法就是你在午餐后打电话给 Bob，而 Bob 必须接到你的电话后才开始吃午餐，所以 b2 > a4。综合所有关系，可推导出：

b3 > b2 > a4 > a3

证明你必定先于Bob用餐。此案例中，午餐事件被序列化（顺序明确），而早餐事件属于并发事件（顺序不可知）。

当我们谈论并发事件时，很容易说它们同时发生。作为简写，这没问题，只要记住严格的定义：  

**若无法通过程序判断两个事件的先后顺序，则称这两个事件为并发事件。**

### 1.4 非确定性

并发程序常具有**非确定性**特征——仅凭代码无法预知执行结果。例如以下程序：
| Thread A  | Thread B  |
|----------------|----------------|
| print("yes")   | print("no")    |

可能的输出结果包括 "yes no" 或 "no yes"，具体取决于操作系统的线程调度。这种非确定性使得并发程序调试异常困难，某些错误可能在千次测试后突然出现。因此，编写同步代码需特别小心。

### 1.5 共享变量

多数情况下，线程的局部变量不会引发同步问题。但当变量被多个线程共享时，复杂情况接踵而至：

#### 1.5.1 并发写入

以下示例展示两个写线程对共享变量 x 的操作：

| Thread A | Thread B |
|----------------|----------------|
| `1` x= 5        | `1` x = 7      |
| `2` print x     |                |

打印输出的 x 的值是什么？当所有这些语句执行完毕时，x的最终值是多少？这取决于语句的执行顺序，称为执行路径。

一种可能的路径是a1 < a2 < b1，在这种情况下，程序的输出是5，但最终值是7。

思考题：哪条路径会产生输出 5 和最终值 5?  
思考题：哪条路径会产生输出 7 和最终值 7?  
思考题：是否存在一条路径产生输出 7 和最终值 5?  

这类问题凸显并发编程的关键：需要全面分析可能的执行路径及其影响，并确保实现预期约束。

#### 1.5.2 并发更新

更新是一种操作，它读取变量的值，根据旧值计算新值，并写入新值。最常见的更新类型是递增，其中新值是旧值加一。以下示例展示了共享变量 `count` 由两个线程并发更新的情况。

| Thread A (You) | Thread B (Bob) |
|----------------|----------------|
| `1` count = count + 1      | `1` count = count + 1      |

乍一看，这里似乎没有明显的同步问题。只有两条执行路径，且结果相同。问题在于这些操作在执行前被转换成了机器语言，在机器语言中，更新需要两个步骤：读取和写入。如果我们用临时变量temp重写代码，这个问题就更加明显了。

| Thread A (You) | Thread B (Bob) |
|----------------|----------------|
| `1` temp = count      | `1` temp = count     |
| `2` count = temp + 1      |`2` count = temp + 1      |

现在考虑执行路径 a1 < b1 < b2 < a2（初始值0）：

这时两线程都读取 0, 都写入 1， 最终值都是 1（而非预期的2）。

这种问题很微妙，因为在查看高级程序时，无法总是判断哪些操作是在单个步骤中执行的，哪些可以被中断。

所以问题源于更新操作的**非原子性**。虽然某些硬件提供原子递增指令，但通用解决方案需依赖同步约束（如互斥锁）确保共享变量访问的串行化。

最常见的约束是互斥，或称为互斥锁，我在第 1.1 节中提到过。互斥保证了任何时候只有一个线程可以访问共享变量，从而消除了本节中的同步错误。

思考题：若 100 个线程各执行 100 次 count +=1，count 的最大可能值是多少？最小值又是多少？（提示：最大值易得，最小值需深入分析）
```python=
for i in range(100):
    temp = count
    count = temp + 1
```

#### 1.5.3 基于消息的互斥

类似于序列化，互斥也可以通过消息传递来实现。例如，想象你和鲍勃共同操作一个核反应堆，你们从远程站点监控它。大多数时候，你们都在关注警告灯，但你们都可以轮流吃午饭。谁先吃午餐并不重要，但非常重要的是，你们不能同时吃饭，以免反应堆无人看管！

思考题：设计一套消息传递（电话）系统来强制执行这些限制。假设没有时钟，且无法预测午餐何时开始或持续多久。所需的消息数量最少是多少？

 
